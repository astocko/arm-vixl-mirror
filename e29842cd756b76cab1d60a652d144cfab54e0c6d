{
  "comments": [
    {
      "key": {
        "uuid": "7a1969be_ee940146",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Could we leave the responsibility of emitting the header, footer, and potential branch over the pool to the MAsm?\n- The PoolManager would only deal with pools themselves.\n- The MAsm can then do whatever it wants, as long as it correctly expresses the constraints to the PoolManager.",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_c101253b",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "I\u0027m not sure how much difference this would make - the details of emitting the header/footer already lies with the MacroAssembler, the pool manager just calls the MacroAssembler methods and adds a branch over the pool or not according to what the MacroAssembler asks for. The pool manager has to know about the alignment of the header and the size of the header to calculate the checkpoint correctly - this info comes from the MacroAssembler when it creates the pool manager.\n\nThe MacroAssembler can also ask for the pools to be emitted conservatively, when there is nothing to be emitted (hence the check at the top of this function), and if the pool is empty then the MacroAssembler should skip emitting the header/footer too, so it\u0027s handy to have one function that does the whole thing for all backends. Perhaps factoring the actual pool object emission out would help here?",
      "parentUuid": "7a1969be_ee940146",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_3f0ad0d2",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "My question/suggestion was about the structure. This is what I would look toward, but I can\u0027t see how realistic it is.\n\nIn my mind the pool header, footer, and branch over the pools, as responsibilities of codegen (so the masm in VIXL), while the pool manager would only be an interface to manage deferred emission of objects. So ideally the pool manager would not be aware of the masm at all.\nOf course we would then need an interface between the masm and the pool manager, that would become the de facto pool manager interface in VIXL. But theoretically, the pool manager logic could be used in other contexts.\n\nHowever I don\u0027t have any use for it! And realistically I don\u0027t expect any soon. So I think it is fair to keep the code as it is.",
      "parentUuid": "3a1371a2_c101253b",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_ce914554",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "\"fixed size instruction set\" or \"fixed instruction size\".",
      "range": {
        "startLine": 60,
        "startChar": 23,
        "endLine": 60,
        "endChar": 44
      },
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_9509232f",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7a1969be_ce914554",
      "range": {
        "startLine": 60,
        "startChar": 23,
        "endLine": 60,
        "endChar": 44
      },
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_6e881123",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 99,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Aren\u0027t `ShouldDeleteWhenPlaced` and `ShouldDeletePoolObjectOnPlacement` redundant?",
      "range": {
        "startLine": 97,
        "startChar": 4,
        "endLine": 99,
        "endChar": 67
      },
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_a1fea936",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 99,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "Yes, I actually initialize one from the other (not sure why, probably premature optimisation :)). I\u0027ll get rid of ShouldDeleteWhenPlaced.",
      "parentUuid": "7a1969be_6e881123",
      "range": {
        "startLine": 97,
        "startChar": 4,
        "endLine": 99,
        "endChar": 67
      },
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_750e2736",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 99,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_a1fea936",
      "range": {
        "startLine": 97,
        "startChar": 4,
        "endLine": 99,
        "endChar": 67
      },
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_4e8d5531",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 188,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "The situation `pc_ \u003e checkpoint_` should not happen. Assert it. Also assert `num_bytes \u003e\u003d 0`. Then this check becomes useless, as covered by the next.",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_01fcdd3d",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 188,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "I\u0027ll modify CheckCurrentPC to add the assertion. But the checks are not redundant - if pc_ \u003d\u003d checkpoint_ and num_bytes \u003d\u003d 0 the second check will return false when we actually need to emit. To do a single check, we can check pc + num_bytes \u003e\u003d checkpoint but this is not the same (it\u0027s slightly more conservative).",
      "parentUuid": "7a1969be_4e8d5531",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_3f1770a5",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 188,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "I had not seen `Current` vs `Future`.\n\nWith the new assertion maybe you can simplify.",
      "parentUuid": "3a1371a2_01fcdd3d",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_151d3367",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 188,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_01fcdd3d",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_ae8209fe",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 203,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Do we *need* that assertion?\nAlthough I guess it won\u0027t happen with standard usage, is there a reason to disallow this?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_219ab914",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 203,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "Only because we don\u0027t handle adding more padding to satisfy the minimum object location than the header size plus required alignment (see Emit()).\n\nThis should not happen with the instructions we support (so we should not need to worry about minimum locations anywhere other than for the first object), but I want to catch if the assumption was incorrect for some reason.",
      "parentUuid": "7a1969be_ae8209fe",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_9f0ca496",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 203,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "Ok. Catching early sounds fine.",
      "parentUuid": "3a1371a2_219ab914",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_c79b0071",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 233,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:44:08Z",
      "side": 1,
      "message": "I did not dig into the code below, but wanted to discuss it. Please correct me if I am wrong!\n\nIt seems to me that the optional arguments and this code are here to handle corner cases for the LabelBase we are about to refer to.\nHowever this does not *guarantee* that we will be able to correctly generate code for the pool and the new reference. So why bother with this complicated code? Could we not get rid of the optional arguments and make this simpler?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_61edd18b",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 233,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "The point of this code is to tell the caller whether it is safe to emit the reference or whether the pools will have to be emitted first. The MacroAssembler would instead check if it is ok to add a reference to the pool\n*before* the reference is emitted. If not, it would ask the pool manager to emit the pool. It is important to be able to guarantee that emitting an instruction with a forward reference will not make pool emission impossible - at the moment (for aarch32) we only attempt to do this for load literal instructions (via rewinding) and we have some subtle bugs in that mechanism too.\n\nIt should be possible to check whether it is safe to emit an instruction at this point (given the information we give to the pool manager about the reference is correct). The first (simpler) check simply tries to see if we can trivially place the new object at the end of the pool. If not, we actually go through recalculating the checkpoint as if we had added the new object to the\npool, and if we end up with an impossible problem (the next pc would already past the checkpoint) we decide we need to emit the pool. It\u0027s similar to emitting the instruction first and then checking whether we have made the problem impossible - the information we need for both \"questions\" is the same, the current state of the pool plus the information for the new instruction.\n\nSo provided we generate one instruction at a time, we should be able to guarantee that we will trigger pool emission if necessary. This does not work if we try to emit multiple instructions that alter the pool state inside a scope that has blocked the pools, but I don\u0027t think this can be made to work without some more complex analysis of all the instructions in the scope, or unless the responsibility of not breaking the pools in that case lies with the user.\n\nThe code can of course have problems we didn\u0027t spot - so feel free to comment in more detail. Keep in mind this version was not aiming to be optimal, but primarily to be correct and make sure we address some remaining issues with pools - therefore you\u0027ll see some TODOs relating to optimisations.",
      "parentUuid": "3a1371a2_c79b0071",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_bf2240ff",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 233,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "Again, this is happening in my head, and maybe cannot happen anywhere else!\n\nTo me it looks like you are doing an optimal effort to correctly generate what is asked. But I am still not sure it guarantees that you will be able to generate what is asked.\n\nWhat if the new constraints imposed by the new `reference` and `label_base` are not compatible with the current constraints in the pool manager?\n\nHitting such a case might be possible because the user asks for something impossible, but also because the placement heuristics are not perfect (and should not be for complexity reasons).\n\nI am thinking of cases that involve an existing forward reference to a literal, followed by a backward reference to the same literal. The placement heuristics guarantee things will work for forward references. But adding this last *backward* reference may not play well.\n\nThe new reference would have a non-null intersection with the existing min/max locations, but force the object to overlap with another object in the pool.\n\nNeither\n1) emitting the pool before the new instruction (without modifying the code generated for the new instruction)\nnor 2) emitting the new instruction and the pool with the reference\nwould work.\n\nIn such a case we will have to emit the pool and then generate different code to refer to the object.\n\nSo my point was, **if** such cases are possible, although rare, is all this complicated logic worth it, since it only makes a best effort for a corner case?\n\nCan you let me know if you share my worry about the possible breaking case idea? If not I\u0027ll try to write a test-case to either prove my point or understand where I am wrong.",
      "parentUuid": "3a1371a2_61edd18b",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_1f771404",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 233,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T05:39:49Z",
      "side": 1,
      "message": "I\u0027ve been thinking more about this while after leaving the bus. Writing things down helped.\n\nIf I read correctly, my test-case is covered as part of the case where the checkpoint is recalculated. What I missed was that if the pool is emitted, codegen will not try to generate code with the same reference!",
      "parentUuid": "3a1371a2_bf2240ff",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_9a3b12eb",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 233,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-25T13:40:14Z",
      "side": 1,
      "message": "Right!\n\nIn the case where we have a reference that triggers pool emission, there are two cases:\n\n1) Simple case: The pool is emitted and it includes the object we are referencing. This means the reference is now a backwards reference and the MacroAssembler will make sure to emit the right code for it (which will likely be different than the forward reference we were attempting to emit). The pool manager is not concerned with backward references.\n\n2) More complicated case: The pool must be emitted, but some objects may be skipped according to heuristics (otherwise we could have too many veneers too soon). None of the emitted objects is the object the new reference refers to. When skipping an object while emitting the pool, we must do so in a way that makes sure we keep it possible to emit the new reference and later emit the pool objects we skipped.\nOne way to think of it is by splitting it in two sub-cases:\na) All objects will be emitted and they do not include the object the new reference refers to (that would be case 1) - in this case we are free to emit the new reference.\nb) Some objects (not including the one the new reference refers to) are emitted and the rest are skipped, then we emit the new reference. I found this case a bit tricky to reason about, but there is a relatively simple check we can do. For making a decision whether to emit pool object X, we assume that if we defer emitting X we will need to fit all the remaining pool objects and footer, including the new object, before being able to emit X again, and only if that is possible we skip emitting the object. This is what ShouldSkipObject() does (in fact it\u0027s even more conservative than that, as it uses an estimate for the *total* pool size added to the new object size and potential alignment, instead of only looking at the remaining objects).",
      "parentUuid": "3a1371a2_1f771404",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_27881422",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:44:08Z",
      "side": 1,
      "message": "objects_.back()",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_d5127b57",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 236,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_27881422",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_8e874d0f",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "This method is called \"often\", but is performing expensive computations. I think the actual work done here can be significantly reduced.\n\n* If `objects_` is always maintained sorted, we can insert new entries at the right place instead of sorting fully.\n\n* To avoid expensive work, we could introduce a `soft_checkpoint_`, that is a conservative estimate of the `checkpoint_`, and updated on operations on the list of objects tracked. We could then compute the precise `checkpoint_` only when we go over `soft_checkpoint_`.",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_819f2d03",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "The first point is on the list of things to look at for making this faster (see TODO in AddObjectReference).\n\nI need to think about the second point - how to calculate a more conservative estimate. Probably would be more similar to our current checkpoint calculation for aarch32? I would prefer to check where most time is spent first, though - this first version is more focused on correctness.",
      "parentUuid": "7a1969be_8e874d0f",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_7f11e8ab",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 287,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "Sounds fine to me. But I know there were some benchmarks that can be critically sensitive to these things. There is a regex JS benchmark for example, that generates many branches and tracks many veneers. So it will be worth keeping an eye on this.",
      "parentUuid": "3a1371a2_819f2d03",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_67820c02",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 359,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:44:08Z",
      "side": 1,
      "message": "Do PoolObjects pointers escape from the PoolManager? If not can we avoid allocating them?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_7988e122",
        "filename": "src/pool-manager-impl.h",
        "patchSetId": 1
      },
      "lineNbr": 359,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_67820c02",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a1969be_0e9cfd68",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Maybe introduce a layer to check (in debug mode) that the masm does not emit more.\n\n    virtual void DoEmitPoolObject(MAsmI *masm) \u003d 0;\n    void EmitPoolObject(MAsmI *masm) {\n      T start \u003d masm-\u003eGetPos();\n      DoEmitPoolObject(mass);\n      T end \u003d mass-\u003eGetPos();\n      VIXL(end - start \u003c\u003d ...);\n    }",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_61a4b157",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "I can do - at the moment I do a less detailed check (if you see I keep track of the pc in PoolManager::Emit() and return the pc the pool manager assumes - so the MacroAssembler can assert they are the same).",
      "parentUuid": "7a1969be_0e9cfd68",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_caabf5d4",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "This change is actually more involved than it sounds, because we don\u0027t have a way to get the pc from the MacroAssemblerInterface at the moment, so I prefer to come back to it in a separate commit.",
      "parentUuid": "3a1371a2_61a4b157",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_07a6b8c1",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "I haven\u0027t had time to dig in details, but I am worried about:\n* overlap between the two\n* keeping them in sync\n\nFor example emission is done via LabelBase: `label_base-\u003eEmitPoolObject(masm);`\nBut the PoolManager tracks the size of the associated PoolObject.\n\n* Can the LabelBase change under the foot of the associated PoolObject?\n* What about live ranges issues? I suppose a `pool_object.abel_base_` is expected to live at least as long as `pool_object`. Is that enforced?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_d5671be9",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 249,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "- The LabelBase should not change under the feet of the associated PoolObject. The only things that can change are whether the LabelBase is bound and its location. For literals, this can only happen for manually placed literals, which we don\u0027t track in the pool manager (we have assertions for this). For Labels, when we have a MacroAssembler, it will always make sure that the bound label is removed from the pool manager. That\u0027s even when Assembler::bind() is called in an ExactAssemblyScope. So I think we shouldn\u0027t have any issues with the LabelObject fields changing unexpectedly. About the slightly messier issue, the lifetime:\n\n- Yes, the LabelBase is expected to live at least as long as the PoolObject. At the moment we do not enforce this, and this is an existing issue. There are simple things that can go wrong: for example, in aarch32, we could construct a RawLiteral with a kDeletedOnPlacementByPool or kDeletedOnPoolDestruction policy *on the stack*. This will obviously go horribly wrong. A different way of dealing with this would possibly be to only allow \"manually deleted\" labels to be constructed directly, or alternatively have the MacroAssembler be responsible for creating the objects with some factory methods and then own them. With manually deleted literals, the only way I can think of to make this fail-safe would be to duplicate the information of the literal value and forward references etc, but then we probably lose some of the reasons we would want to use manually deleted literals in the first place. This is something we should look at, I think (and it has come up in discussions before), but it is kind of orthogonal to this change and would be hard to fix without breaking current usage.\n\nAbout overlap between the objects, I\u0027ve removed size_ from the PoolObject (redundant). The alignment field is necessary as it can be restricted by the various references.",
      "parentUuid": "3a1371a2_07a6b8c1",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_67ab2c8a",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Catch incompatible restrictions in debug mode.\n\nI think it could fairly easily happen for literals on T32. But it could be something we want to handle for advanced uses.\nFor example when trying to have a global patchable\nreference (e.g. a function address). It seems to me that with this new\ndesign we could handle from the start \"auto-duplicating\" pool objects, that\nwould show to the user as a single object, but actually live in multiple\nplaces in the stream.",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_15b9b32e",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 277,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_67ab2c8a",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_87910855",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 372,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "Nit: `size_` and `object_alignment_` together to allow packing when T\u003d\u003d64 and int\u003d\u003d32?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_f519777a",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 372,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_87910855",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_a7940445",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "The trick I was using here was to delete elements by writing an invalid address marker (e.g. 0xbad), and having the algorithms work around it. This way deleting is cheap, and you can compact only at certain points (e.g. after emission).",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_47b0b0f4",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 514,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:14:17Z",
      "side": 1,
      "message": "unordered_map?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_f5b5f731",
        "filename": "src/pool-manager.h",
        "patchSetId": 1
      },
      "lineNbr": 514,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "I can\u0027t use it here (C++11), but I\u0027ve removed this map anyway.",
      "parentUuid": "3a1371a2_47b0b0f4",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_a77b6428",
        "filename": "src/utils-vixl.h",
        "patchSetId": 1
      },
      "lineNbr": 471,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:50:04Z",
      "side": 1,
      "message": "Share with above?\n\n`T* pointer` to really restrict to pointer types?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_c18805c9",
        "filename": "src/utils-vixl.h",
        "patchSetId": 1
      },
      "lineNbr": 471,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-04-20T18:23:24Z",
      "side": 1,
      "message": "It\u0027s not only used for pointer types - the locations etc in the pool manager are cursor offsets (so will be int32_t for aarch32 and int64_t for aarch64).",
      "parentUuid": "3a1371a2_a77b6428",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_df257c0b",
        "filename": "src/utils-vixl.h",
        "patchSetId": 1
      },
      "lineNbr": 471,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-25T02:11:55Z",
      "side": 1,
      "message": "My primary point was about sharing the implementations. If there is a reason not to share, maybe distinguish the two. Should it be T* pointer above?",
      "parentUuid": "3a1371a2_c18805c9",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_0ab6ad3d",
        "filename": "src/utils-vixl.h",
        "patchSetId": 1
      },
      "lineNbr": 471,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a1371a2_df257c0b",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_078d1832",
        "filename": "test/test-pool-manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000284
      },
      "writtenOn": "2017-04-11T01:44:08Z",
      "side": 1,
      "message": "Would it make sense to do this as part of `pool_manager.AddObjectReference(...)` to reduce the code?",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1371a2_999e7d55",
        "filename": "test/test-pool-manager.cc",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2017-05-03T16:13:35Z",
      "side": 1,
      "message": "This would complicate integration quite a bit (due to the very different implementations of keeping track of references for aarch32 and aarch64) so I intentionally avoided making keeping track of references part of LabelBase (implementations can do whatever they want as the code is now). There are also references that the pool manager knows nothing about so I didn\u0027t want to impose a virtual method as an abstract interface for adding references to LabelBase either.",
      "parentUuid": "3a1371a2_078d1832",
      "revId": "e29842cd756b76cab1d60a652d144cfab54e0c6d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    }
  ]
}