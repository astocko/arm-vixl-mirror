{
  "comments": [
    {
      "key": {
        "uuid": "ba068154_4f3f0d26",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000221
      },
      "writtenOn": "2016-09-01T14:55:11Z",
      "side": 1,
      "message": "Your prototype is not consistent. You give a \"uint16_t*\" and your return the number of uint8_t decoded.\nYou should return a \"uint16_t*\". This way, it would be easier to use (specially in DisassembleT32Buffer).",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_af1799a2",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000226
      },
      "writtenOn": "2016-09-01T14:58:41Z",
      "side": 1,
      "message": "You need a slightly different name since hte semantic is different. How about DecodeT32At(...)",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_cf12ddb3",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-09-01T15:01:17Z",
      "side": 1,
      "message": "As mentioned, I was being consistent with T32Size() (so the method is essentially a combination of DecodeT32() and T32Size() with a pointer argument), but this is easily fixable.\n\nWhen you say \"You should return a \"uint16_t*\", I suppose you mean that I should return a value in uint16_t units, which will still be an int, as opposed to returning a pointer, right?",
      "parentUuid": "ba068154_4f3f0d26",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_2f6a891a",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-09-01T15:23:32Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ba068154_af1799a2",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_af65d946",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000221
      },
      "writtenOn": "2016-09-01T15:24:37Z",
      "side": 1,
      "message": "No, you should return a pointer. This avoid any ambiguity and avoid all the arithmetic you do in DisassembleT32Buffer. It becomes:\nbuffer \u003d DecodeT32(buffer);",
      "parentUuid": "ba068154_cf12ddb3",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_ef5fe170",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000194
      },
      "writtenOn": "2016-09-01T15:28:11Z",
      "side": 1,
      "message": "Tony for Vincent\u0027s benefit can you please post the ugliness that this is trying to solve?",
      "parentUuid": "ba068154_af65d946",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_2f51e962",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-09-01T15:29:37Z",
      "side": 1,
      "message": "Isn\u0027t that a little bit too specialized for DisassembleT32Buffer()? Generally speaking, the intent is to disassemble exactly one function and obtain its size. There isn\u0027t necessarily a whole buffer of instructions that need processing.",
      "parentUuid": "ba068154_af65d946",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_cfc77d11",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-09-01T15:39:30Z",
      "side": 1,
      "message": "The ART code looks like this:\n\n size_t DisassemblerArm::DumpInstruction(const uint8_t* instr_ptr,\n                                         bool is_t32,\n                                         std::ostream\u0026 os) {\n   size_t ret;\n \n   disasm_.ResetStreamPc();\n \n   if (is_t32) {\n     const uint16_t* const ip \u003d reinterpret_cast\u003cconst uint16_t*\u003e(instr_ptr);\n \n     // The T32Size() method needs only the first 16 bits of the instruction,\n     // and expects them to occupy the most significant bytes of its input.\n     ret \u003d disasm_.T32Size(*ip \u003c\u003c 16);\n     disasm_.DisassembleT32Buffer(ip, ret);\n   } else {\n     ret \u003d vixl::aarch32::kA32InstructionSizeInBytes;\n     disasm_.DecodeA32(*reinterpret_cast\u003cconst uint32_t*\u003e(instr_ptr));\n   }\n \n   os \u003c\u003c output_.str();\n   output_.str(std::string());\n   return ret;\n }\n\nWith the proposed changes it will look like this:\n\n size_t DisassemblerArm::DumpInstruction(const uint8_t* instr_ptr,\n                                         bool is_t32,\n                                         std::ostream\u0026 os) {\n   size_t ret;\n \n   disasm_.ResetStreamPc();\n \n   if (is_t32) {\n     const uint16_t* const ip \u003d reinterpret_cast\u003cconst uint16_t*\u003e(instr_ptr);\n \n     ret \u003d disasm_.DecodeT32At(ip) * sizeof(*ip);\n   } else {\n     const uint32_t* const ip \u003d reinterpret_cast\u003cconst uint32_t*\u003e(instr_ptr);\n \n     ret \u003d disasm_.DecodeA32At(ip) * sizeof(*ip);\n   }\n \n   os \u003c\u003c output_.str();\n   output_.str(std::string());\n   return ret;\n }",
      "parentUuid": "ba068154_ef5fe170",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba068154_0fd225d2",
        "filename": "src/aarch32/disasm-aarch32.cc",
        "patchSetId": 2
      },
      "lineNbr": 67291,
      "author": {
        "id": 1000221
      },
      "writtenOn": "2016-09-01T15:41:08Z",
      "side": 1,
      "message": "If you use this function, that means that you have the instruction into a buffer (even if the buffer is only 2 bytes). It\u0027s consistent to return a pointer. If you still need the size, you can always do the opposite you did in DisassembleT32Buffer which gives.\n\nconst uint16_t* buffer \u003d ...\nint size \u003d (DecodeT32(buffer) - buffer) * sizeof(*buffer);",
      "parentUuid": "ba068154_2f51e962",
      "revId": "5f4b03417043dea2999d44adece81778ff4c878d",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    }
  ]
}