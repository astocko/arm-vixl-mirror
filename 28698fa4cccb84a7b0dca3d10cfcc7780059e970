{
  "comments": [
    {
      "key": {
        "uuid": "da01753e_731133ac",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 300,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T12:22:07Z",
      "side": 1,
      "message": "\"clang-format\" suggested this.",
      "range": {
        "startLine": 299,
        "startChar": 32,
        "endLine": 300,
        "endChar": 5
      },
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_f3736313",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2209,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T12:54:02Z",
      "side": 1,
      "message": "I\u0027m not sure that this algorithm is quite right. For example, it does the wrong thing if the base register is unaligned. (That is likely if using a custom stack pointer, for example.)\n\nV8 provides another interesting real-world example: The base register of a tagged value is never aligned, but we fix it in the offset. base+offset is aligned, but neither component is.",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_f38fe3ca",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2209,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T14:21:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "da01753e_f3736313",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_3365eb45",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T12:54:02Z",
      "side": 1,
      "message": "I think it would suffice to just say that we try to keep accesses aligned wherever possible. The logic should also apply sensibly if we have registers of different sizes.",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_53bcef6c",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T14:21:09Z",
      "side": 1,
      "message": "I don\u0027t think that the purpose of this code will be clear to an unfamiliar reader without mentioning that it is a microarchitectural constraint. IMHO if I just mention alignment (without qualifying), people will just assume the natural data type alignment, which is definitely not the idea, so it will only serve to create further confusion.",
      "parentUuid": "da01753e_3365eb45",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_73bbf372",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T14:40:34Z",
      "side": 1,
      "message": "Perhaps, but note that we don\u0027t have any micro-architecture-specific behaviour in VIXL. In any case, it\u0027s not natural alignment, but twice the natural alignment that we want. That is, if we\u0027re handling W registers, we want the ldp/stp instructions to be 8-byte aligned, otherwise they can span 64- or 16-byte boundaries just like X register operations could.\n\nI think it\u0027s clear to state that we want 2n-byte operations to be 2n-byte aligned, where the registers are n bytes wide. That\u0027s as close we can get to avoiding the boundaries anyway.\n\nThe best guarantee we have on the base register is that it is 16-byte aligned (for the stack pointer); there\u0027s no point talking about 64-bit boundaries because at this point we have no way to influence them.",
      "parentUuid": "da01753e_53bcef6c",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_53634f1a",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T15:14:38Z",
      "side": 1,
      "message": "In the next revision I was going to check for the following conditions:\nloc.GetOffset() % reg_size \u003d\u003d 0\nloc.GetOffset() % 2 * reg_size !\u003d 0\nregisters.GetCount() % 2 !\u003d 0\nloc.GetBaseRegister().IsSP()\n!IsAligned\u003c16\u003e(loc.GetOffset())\nreg_size \u003c 16\n\nIn this case we can definitely influence 64 byte boundaries (never crossing 16 byte boundaries with a 16 byte stride ensures it).\n\nOr would you rather prefer to enforce the simple constraint about 2n-byte operations (i.e. only the first three conditions from the list above)? Of course, it has the drawback that the assembler might rearrange the code, even though it is unnecessary.",
      "parentUuid": "da01753e_73bbf372",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_936db707",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T15:20:58Z",
      "side": 1,
      "message": "Disregard \"reg_size \u003c 16\", I just realized that it was implied by the rest.",
      "parentUuid": "da01753e_53634f1a",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_d30bbf29",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2210,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T15:47:49Z",
      "side": 1,
      "message": "I\u0027ll have to think about it. We can discuss it when I\u0027m in the office on Monday if you like.",
      "parentUuid": "da01753e_53634f1a",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_53606f35",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2212,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T12:54:02Z",
      "side": 1,
      "message": "During the week, I spoke to Alexandre about this, and we discussed the possibility of handling sequences like str+stp+stp+str, where the location is unaligned but there are an even number of registers. With a long enough register list, it might be better to add an extra operation in order to keep the majority of the accesses aligned.",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_b3855baf",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2212,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T14:21:09Z",
      "side": 1,
      "message": "I haven\u0027t done the necessary testing to determine the threshold value, so currently I have chosen a conservative approach (i.e. apply the change only to an odd number of registers), which never introduces regressions.",
      "parentUuid": "da01753e_53606f35",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_1320a7f6",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T12:54:02Z",
      "side": 1,
      "message": "Extra parentheses would make this much clearer.\n\nI don\u0027t like the hard-coded alignment sizes. (As discussed above, this function handles all register sizes.)",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_d388dfc8",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T14:21:09Z",
      "side": 1,
      "message": "Extra parentheses where? Around \"registers.GetCount() % 2 !\u003d 0\"? As for the hard-coded alignment sizes, the 16 byte one is independent of the register sizes (as mentioned, it is a microarchitectural constraint), so I don\u0027t see how to replace it. I will fix the 8 byte one.",
      "parentUuid": "da01753e_1320a7f6",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_93b65789",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T14:40:34Z",
      "side": 1,
      "message": "\"((registers.GetCount() % 2) !\u003d 0)\"\n\nYes, I know it\u0027s unambiguous, but the parentheses made the behaviour more obvious and thus faster to read. (It\u0027s also VIXL style.)",
      "parentUuid": "da01753e_d388dfc8",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_d3761fd8",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T15:28:26Z",
      "side": 1,
      "message": "What about \"!!(...)\"? I generally go for shorter sequences...",
      "parentUuid": "da01753e_93b65789",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_d35d7f4a",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T15:31:08Z",
      "side": 1,
      "message": "Actually, in this case I\u0027d rather drop the \" !\u003d 0\" completely.",
      "parentUuid": "da01753e_d3761fd8",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_331deb74",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2213,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T15:47:49Z",
      "side": 1,
      "message": "We always explicitly check against 0, nullptr and suchlike. Consistency is more important than saving a few characters.",
      "parentUuid": "da01753e_d35d7f4a",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_935ad781",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2222,
      "author": {
        "id": 1000218
      },
      "writtenOn": "2016-06-17T12:54:02Z",
      "side": 1,
      "message": "Again, this assumes the use of X registers.",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da01753e_139387fb",
        "filename": "src/a64/macro-assembler-a64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2222,
      "author": {
        "id": 1000234
      },
      "writtenOn": "2016-06-17T14:21:09Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "da01753e_935ad781",
      "revId": "28698fa4cccb84a7b0dca3d10cfcc7780059e970",
      "serverId": "f33910f19b7abb192b83adbd000000bf",
      "unresolved": false
    }
  ]
}